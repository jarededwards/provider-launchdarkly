/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ClientSideAvailabilityObservation struct {
}

type ClientSideAvailabilityParameters struct {

	// +kubebuilder:validation:Optional
	UsingEnvironmentID *bool `json:"usingEnvironmentId,omitempty" tf:"using_environment_id,omitempty"`

	// +kubebuilder:validation:Optional
	UsingMobileKey *bool `json:"usingMobileKey,omitempty" tf:"using_mobile_key,omitempty"`
}

type CustomPropertiesObservation struct {
}

type CustomPropertiesParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Value []*string `json:"value" tf:"value,omitempty"`
}

type DefaultsObservation struct {
}

type DefaultsParameters struct {

	// The index of the variation served when the flag is off for new environments
	// +kubebuilder:validation:Required
	OffVariation *float64 `json:"offVariation" tf:"off_variation,omitempty"`

	// The index of the variation served when the flag is on for new environments
	// +kubebuilder:validation:Required
	OnVariation *float64 `json:"onVariation" tf:"on_variation,omitempty"`
}

type FlagObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type FlagParameters struct {

	// Whether to archive the flag
	// +kubebuilder:validation:Optional
	Archived *bool `json:"archived,omitempty" tf:"archived,omitempty"`

	// +kubebuilder:validation:Optional
	ClientSideAvailability []ClientSideAvailabilityParameters `json:"clientSideAvailability,omitempty" tf:"client_side_availability,omitempty"`

	// +kubebuilder:validation:Optional
	CustomProperties []CustomPropertiesParameters `json:"customProperties,omitempty" tf:"custom_properties,omitempty"`

	// The default variations used for this flag in new environments. If omitted, the first and last variation will be used
	// +kubebuilder:validation:Optional
	Defaults []DefaultsParameters `json:"defaults,omitempty" tf:"defaults,omitempty"`

	// A short description of what the flag will be used for
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Whether or not this flag should be made available to the client-side JavaScript SDK
	// +kubebuilder:validation:Optional
	IncludeInSnippet *bool `json:"includeInSnippet,omitempty" tf:"include_in_snippet,omitempty"`

	// A unique key that will be used to reference the flag in your code
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// The LaunchDarkly id of the user who will maintain the flag
	// +kubebuilder:validation:Optional
	MaintainerID *string `json:"maintainerId,omitempty" tf:"maintainer_id,omitempty"`

	// A human-friendly name for the feature flag
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The LaunchDarkly project key
	// +kubebuilder:validation:Required
	ProjectKey *string `json:"projectKey" tf:"project_key,omitempty"`

	// Tags associated with your resource
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Whether or not the flag is a temporary flag
	// +kubebuilder:validation:Optional
	Temporary *bool `json:"temporary,omitempty" tf:"temporary,omitempty"`

	// The uniform type for all variations. Can be either "boolean", "string", "number", or "json".
	// +kubebuilder:validation:Required
	VariationType *string `json:"variationType" tf:"variation_type,omitempty"`

	// An array of possible variations for the flag
	// +kubebuilder:validation:Optional
	Variations []VariationsParameters `json:"variations,omitempty" tf:"variations,omitempty"`
}

type VariationsObservation struct {
}

type VariationsParameters struct {

	// A description for the variation
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// A name for the variation
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The value of the flag for this variation
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

// FlagSpec defines the desired state of Flag
type FlagSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     FlagParameters `json:"forProvider"`
}

// FlagStatus defines the observed state of Flag.
type FlagStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        FlagObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Flag is the Schema for the Flags API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,launchdarkly}
type Flag struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              FlagSpec   `json:"spec"`
	Status            FlagStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// FlagList contains a list of Flags
type FlagList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Flag `json:"items"`
}

// Repository type metadata.
var (
	Flag_Kind             = "Flag"
	Flag_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Flag_Kind}.String()
	Flag_KindAPIVersion   = Flag_Kind + "." + CRDGroupVersion.String()
	Flag_GroupVersionKind = CRDGroupVersion.WithKind(Flag_Kind)
)

func init() {
	SchemeBuilder.Register(&Flag{}, &FlagList{})
}
